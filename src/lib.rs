use anyhow::{anyhow, Context};
use clap::Args;
use paho_mqtt::AsyncClient;
use serde::{Deserialize, Serialize};
use spin_app::App;
use spin_factor_variables::VariablesFactor;
use spin_factors::RuntimeFactors;
use spin_trigger::{Trigger, TriggerApp};
use std::{sync::Arc, time::Duration};

// https://docs.rs/wasmtime/latest/wasmtime/component/macro.bindgen.html
wasmtime::component::bindgen!({
    path: ".",
    world: "spin-mqtt",
    imports: { default: async },
    exports: { default: async },
});

use spin::mqtt_trigger::spin_mqtt_types as mqtt_types;

// The trigger structure with all values processed and ready
#[derive(Clone)]
pub struct MqttTrigger {
    /// Trigger settings
    metadata: TriggerMetadata,
    /// Per-component settings
    component_configs: Vec<ComponentConfig>,
    /// Whether to run in test mode
    test: bool,
}

impl<F: RuntimeFactors> Trigger<F> for MqttTrigger {
    const TYPE: &'static str = "mqtt";
    type InstanceState = ();
    type CliArgs = CliArgs;

    fn new(cli_args: Self::CliArgs, app: &App) -> anyhow::Result<Self> {
        let trigger_type = <Self as Trigger<F>>::TYPE;
        let metadata = app
            .get_trigger_metadata::<TriggerMetadata>(trigger_type)?
            .unwrap_or_default();

        let component_configs = app
            .trigger_configs::<ComponentConfig>(trigger_type)?
            .into_iter()
            .map(|(_, config)| config)
            .collect();

        Ok(Self {
            metadata,
            component_configs,
            test: cli_args.test,
        })
    }

    async fn run(mut self, trigger_app: TriggerApp<Self, F>) -> anyhow::Result<()> {
        if self.test {
            for component in &self.component_configs {
                self.handle_mqtt_event(
                    &trigger_app,
                    &component.component,
                    b"test message".to_vec(),
                    "test".to_string(),
                )
                .await?;
            }

            Ok(())
        } else {
            self.metadata.resolve_variables(&trigger_app).await?;
            tokio::spawn(async move {
                // This trigger spawns threads, which Ctrl+C does not kill. So
                // for this case we need to detect Ctrl+C and shut those threads
                // down. For simplicity, we do this by terminating the process.
                tokio::signal::ctrl_c()
                    .await
                    .expect("failed to listen for Ctrl+C");
                std::process::exit(0);
            });

            let trigger = Arc::new(self);
            let trigger_app = Arc::new(trigger_app);
            let tasks = trigger.component_configs.iter().map(|component_config| {
                let trigger = trigger.clone();
                let trigger_app = trigger_app.clone();
                let component_config = component_config.clone();
                tokio::spawn(
                    async move { trigger.run_listener(&trigger_app, component_config).await },
                )
            });

            // wait for the first handle to be returned and drop the rest
            let (result, _, rest) = futures::future::select_all(tasks).await;

            drop(rest);
            result?
        }
    }
}

impl MqttTrigger {
    /// Handle a specific MQTT event
    async fn handle_mqtt_event<F: RuntimeFactors>(
        &self,
        trigger_app: &TriggerApp<Self, F>,
        component_id: &str,
        message: Vec<u8>,
        topic: String,
    ) -> anyhow::Result<()> {
        // Load the guest wasm component
        let instance_builder = trigger_app.prepare(component_id)?;
        let (instance, mut store) = instance_builder.instantiate(()).await?;
        // SpinMqtt is auto generated by bindgen as per WIT files referenced above.
        let instance = SpinMqtt::new(&mut store, &instance)?;

        instance
            .call_handle_message(store, &message, &mqtt_types::Metadata { topic })
            .await?
            .map_err(|err| anyhow!("failed to execute guest: {err}"))
    }

    /// Run the listener for a specific component
    async fn run_listener<F: RuntimeFactors>(
        &self,
        trigger_app: &TriggerApp<Self, F>,
        config: ComponentConfig,
    ) -> anyhow::Result<()> {
        let topic = resolve_variables(trigger_app, config.topic).await?;

        // Receive the messages here from the specific topic in mqtt broker.
        let mut client = AsyncClient::new(self.metadata.address.as_str())?;
        let keep_alive_interval = self.metadata.keep_alive_interval.parse::<u64>()?;
        let conn_opts = paho_mqtt::ConnectOptionsBuilder::new()
            .keep_alive_interval(Duration::from_secs(keep_alive_interval))
            .user_name(&self.metadata.username)
            .password(&self.metadata.password)
            .finalize();

        client
            .connect(conn_opts)
            .await
            .context(format!("failed to connect to '{}'", self.metadata.address))?;
        let qos = config.qos.parse::<i32>()?;
        client
            .subscribe(&topic, qos)
            .await
            .context(format!("failed to subscribe to '{topic}'"))?;

        // TODO: Should the buffer be bounded/configurable?
        let rx = client.get_stream(None);

        loop {
            match rx.recv().await {
                Ok(Some(msg)) => {
                    // Handle the received message
                    if let Err(e) = self
                        .handle_mqtt_event(
                            trigger_app,
                            &config.component,
                            msg.payload().to_vec(),
                            msg.topic().to_owned(),
                        )
                        .await
                    {
                        tracing::error!("Error handling MQTT message: {:?}", e);
                    }
                }
                Ok(None) => {
                    // Todo: Figure out what this case is
                }
                Err(_) => {
                    // Channel is empty and closed
                    break;
                }
            }
        }

        Ok(())
    }
}

/// Command line arguments
#[derive(Args)]
pub struct CliArgs {
    /// If true, run each component once and exit
    #[clap(long)]
    pub test: bool,
}

// Trigger settings (raw serialization format)
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
struct TriggerMetadata {
    address: String,
    username: String,
    password: String,
    keep_alive_interval: String,
}

impl TriggerMetadata {
    /// Resolve any variables inside the trigger metadata.
    async fn resolve_variables<F: RuntimeFactors>(
        &mut self,
        trigger_app: &TriggerApp<MqttTrigger, F>,
    ) -> anyhow::Result<()> {
        let address = resolve_variables(trigger_app, self.address.clone()).await?;
        let username = resolve_variables(trigger_app, self.username.clone()).await?;
        let password = resolve_variables(trigger_app, self.password.clone()).await?;
        self.address = address;
        self.username = username;
        self.password = password;
        Ok(())
    }
}

// Per-component settings (raw serialization format)
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ComponentConfig {
    /// The component id
    component: String,
    /// The topic
    topic: String,
    /// The QoS level
    qos: String,
}

/// Resolve variables in an expression against the variables in the provided trigger app.
async fn resolve_variables<F: RuntimeFactors>(
    trigger_app: &TriggerApp<MqttTrigger, F>,
    expr: String,
) -> anyhow::Result<String> {
    match trigger_app.configured_app().app_state::<VariablesFactor>() {
        Ok(variables) => anyhow::Ok(variables.resolve_expression(expr).await?),
        Err(spin_factors::Error::NoSuchFactor(_)) => Ok(expr),
        Err(err) => Err(err.into()),
    }
}
